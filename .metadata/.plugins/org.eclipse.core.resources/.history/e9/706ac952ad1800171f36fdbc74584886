
/**
 * Algorithm to solve 0-1 Knapsack using dynamic programming with value function
 * V(i,W).
 * 
 * @author jstekete
 *
 */
public class AlgorithmNW {

	public static Solution solve(Itemset itemset, int capacity) {
		Item[] items = itemset.items;

		int[][] value = new int[items.length][capacity + 1];
		boolean[][] choice = new boolean[items.length][capacity + 1];
		Item curItem;

		int take;
		int skip;
		for (int i = items.length - 1; i >= 0; i--) {
			for (int w = 0; w < value[0].length; w++) {
				curItem = items[i];
				if (i == items.length) {
					if (w - curItem.weight < 0) {
						value[i][w] = 0;
						choice[i][w] = false;
					} else {
						value[i][w] = curItem.value;
						choice[i][w] = true;
					}
				} else {
					if (w - curItem.weight < 0) {
						value[i][w] = value[i + 1][w];
						choice[i][w] = false;
					} else {
						take = value[i + 1][w - curItem.weight] + curItem.value;
						skip = value[i][w];
						if (take > skip) {
							value[i][w] = take;
							choice[i][w] = true;
						} else {
							value[i][w] = skip;
							choice[i][w] = false;
						}
					}
				}
			}
		}
		int i = 0; 
		int w = capacity; 
		int maxVal = value[0][capacity];
		
		

		return null;
	}
}
